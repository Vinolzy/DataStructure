1.数据的逻辑结构是数据元素间关系的描述。
2.数据结构研究非数值计算问题中计算机的操作对象以及它们之间的关系和运算的学科
3.计算机算法必须具备输入、输出和可行性、确定性和有穷性等五个特性
4.n个元素的顺序表删除一个元素移动的平均次数为(n-1)/2
5.将长度为n的单链表连接在长度为m的单链表之后的算法的时间复杂度为O(m) 找到表尾
6.队列：队尾出队，对首入队
7.广义表是一种递归的数据结构.长度为最外层括号所包含的元素个数。深度是最内层括号所在的重数。长度有限，深度有可能无穷大。原子深度为0，空表为1
8.表头:非空广义表的第一个元素     表尾:除去表头之外，其余元素所构成的表
9.广义表和稀疏矩阵的共同点:数据元素本身是一个数据结构
10.队列: 空Q.front=Q.rear  满:(Q.rear+1)%max=Q.front 浪费一个单元，rear指向最后一个元素的下一个位置。
元素个数:(Q.rear-Q.front+max)%max
11.树:二叉树叶子数n0=n2+1     n个结点的完全二叉树深度:log2n向下取整+1
完全二叉树:k-1层满。
二叉线索树:加快查找结点的前驱或后继的速度
12.森林:左是第一个孩子，右是下一个兄弟。
树、森林、二叉树 先根遍历相同。树的后根和森林、二叉树的中序遍历相同。
13.哈弗曼树无度为1的点
----二、五--------------
单链表插入 while(p&&j<i-1){p=p->next;j++;}到i-1结点。if(!p||j>=i-1)return error;
单链表删除 把上述代码p换成p->next
链队:往后加往前出。 typedef struct QNode{int data;struct QNode *next;}QNode,*QueuePtr;
					typedef struct{QueuePtr front;QueuePtr rear;}LinkQueue;
-----------------------------------------------
若一个结点是某二叉树的中序遍历序列的最后一个结点，则它必是该树的前序遍历序列中的最后一个结点。 (×) A-B-C 中ABC前CBA

有一个四叉树，度2的结点数为2，度3的结点数为3，度4的结点数为4。问该树的叶结点个数是多少？
边数=结点数-1 --- 4+9+16+n1+0*n0=2+3+4+n1+n0-1    n0=21

对于一个有N个结点、K条边的森林，能确定它共有几棵树:
一棵:边数=结点数-1，两棵:边数=结点数-2 所以为结点数-边数
例:由若干个二叉树组成的森林F中，叶结点总个数为N，度为2的结点总个数为M，则该集合中二叉树的个数为 n0+n1+n2-(2*n2+n1)=n0-n2=N-M

设一段文本中包含4个对象{a,b,c,d}，其出现次数相应为{4,2,5,1}，则该段文本的哈夫曼编码比采用等长方式的编码节省了多少位数？ 2
算出哈夫曼长度为22.等长:(4+2+5+1)*2=24 
---------------------查找---------------------------
二叉排序树=二叉搜索树=二叉查找树 最小值一定在叶结点，最大值不一定
折半查找二叉树判定树的深度(最大比较次数)为log2n向下取整+1
画折半查找判定树的时候从1开始标号。低+高/2 可向上和向下取整
-----------------------图---------------------------
1.邻接表与边数有关，邻接矩阵与结点数有关
2.有向图中,入度=出度=边数
3.无向连通图所有顶点的度之和为偶数。无向图边数的两倍等于各顶点度数的总和。
例：已知无向图G含有16条边，其中度为4的顶点个数为3，度为3的顶点个数为4，其他顶点的度均小于3。图G所含的顶点个数至少是：32≥12+12+2x   x+7=11
4.无向图G必须进行两次广度优先搜索才能访问其所有顶点，则G一定有2个连通分量。
5.强连通分量：有向图中的极大强连通子图称作有向图的强连通分量.
在有向图G中，如果两个顶点vi,vj间（vi>vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通。如果有向图G的每两个顶点都强连通，称G是一个强连通图。
完全图:是一个简单的无向图，其中每对不同的顶点之间都恰连有一条边相连
6.无向图有n个顶点，保证图连通，最少边为(n-1)(n-2)/2+1
7.如果G是一个有36条边的非连通无向图，那么该图顶点个数最少为多少?(n-1)(n-2)/2+1>36   10
8.设N个顶点E条边的图用邻接表存储，则求每个顶点入度/拓扑排序算法时间复杂度为O(N+E)
9.图的深度优先遍历类似于二叉树的先序遍历
10.在拓扑排序算法中用堆栈和用队列产生的结果有可能不同
一个具有n个顶点的有向完全图的弧数为n(n-1)
直接插入比较次数最少:逆序数最少https://jingyan.baidu.com/article/6dad50755354c6a123e36e2b.html
--------------------
<deque>可以在两端输出 A.front() A.pop_front()
priority_queue<int,vector<int>,greater<int> >p;  map<string,string>father;
string s;getline(cin,s);count(s.begin(),s.end(),' ');
s=s.substr(cnt)截去前cnt个字符，也可substr(a,b)区间截去
cin.get()等价于getchar()
---
1.快速排序在基本有序情况下时间复杂度最高.元素全部相同时,由于不需比较(左右指针移动),时间复杂度nlogn。只要有一个指针不移动为N^2。算法实现为设置一个关键字，然后在左右递归实现。
2.建初堆从n/2向下取整开始
2.次位优先（LSD）链式基数排序:从个位往上一步步排序
3.大文件排序:归并
4.希尔排序和堆排序需要顺序存储,链式存储结构会增大时间复杂度。
5.堆排序、快速排序、希尔排序不稳定。
---
void shell_sort(int a[], int N )
{
	int tmp;
	int  i;
	for (int d=N/2; d>0; d/=2)
	{
		for (int j=d; j<N; ++j)
		{
			tmp = a[j];
			for (i=j; i>=d && a[i-d]>tmp; i-=d)
				a[i] = a[i-d];
			a[i] = tmp;
		}
	}
}
set_intersection（取集合交集）、set_union（取集合并集）、set_difference（取集合差集）、set_symmetric_difference（取集合对称差集）
set_union(a.begin(),a.end(),b.begin(),b.end(),inserter(c, c.begin()));